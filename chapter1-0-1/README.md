#  Spring IoC 应运而生
    概念：要了解IoC控制反转( Inversion of Control ), 有必要先了解软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）。
    
    #item01
    假设我们设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。
    这里就出现了一个“依赖”关系：汽车--->车身--->底盘--->轮子
    这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。
    这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；
    同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！
    
    
    #item02
    这样，就相当于上层建筑依赖下层建筑——每一个类的构造函数都直接调用了底层代码的构造函数。
    假设我们需要改动一下轮胎（Tire）类，把它的尺寸变成动态的，而不是一直都是30
    我们需要更改 Tire Framework Bottom Car 所有类的构造函数  来传入 size 参数
    
    由此我们可以看到，仅仅是为了修改轮胎的构造函数，这种设计却需要修改整个上层所有类的构造函数！
    在软件工程中，这样的设计几乎是不可维护的
    在实际工程项目中，有的类可能会是几千个类的底层，如果每次修改这个类，我们都要修改所有以它作为依赖的类，那软件的维护成本就太高了。 
    
    #item03
    所以我们需要进行控制反转（IoC），来实现上层控制下层，而不是下层控制着上层。
    我们用依赖注入（Dependency Injection）这种方式来实现控制反转。
    所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。
    这里我们用构造方法传递的依赖注入方式重新写车类的定义：
    
    我们现在换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。
    这时候，依赖关系就倒置过来了：汽车<---车身<---底盘<---轮子 
    这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了。
    
    这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。
    高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。
    这样就不会出现前面的“牵一发动全身”的情况。
    
    
    1. IoC的好处是：如果依赖的接口的实现类修改了，比如修改了构造函数，如果没有依赖注入，
        则需要修改依赖对象调用者的代码(new 那块的代码)，如果依赖注入则不需要！